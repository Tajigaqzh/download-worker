"use strict";!function(){let e=1e3;class t{static#e=null;#t=1;#r=null;#n=[];#s="";#i=100;constructor({dbName:r,batchMax:n=100,maxInitialLimitCount:s=1e3}){if(!r||0===r.trim().length)throw new Error("db name error");if(e&&s>e&&(e=s),t.#e)return t.#e;this.#s=r,this.#i=n,t.#e=this}isExistDB=()=>null!==this.#r;isExistTable=e=>!!this.#r&&this.#r.objectStoreNames.contains(e);async initialize(){if(!self.indexedDB)throw new Error("current environment not supported IndexDB");if(this.#r)return Promise.resolve(!0);let t=!1,r=0;const n=()=>new Promise(((e,t)=>{const r=self.indexedDB.open(this.#s,this.#t);r.onupgradeneeded=e=>{const t=e.target.result;this.#o(t,e.oldVersion)},r.onsuccess=t=>{this.#r=t.target.result,e(!0)},r.onerror=t=>{e(!1)}}));for(;r<e&&!t;){if(r++,await n())return t=!0,Promise.resolve(!0);this.#t++}return Promise.reject("创建失败")}destroy(){this.#r&&(this.#r.close(),this.#r=null)}#o(e,t){Array.from(e.objectStoreNames).forEach((t=>{this.#n.some((e=>e.name===t))||e.deleteObjectStore(t)})),this.#n.forEach((t=>{e.objectStoreNames.contains(t.name)||this.#a(e,t)}))}#a(e,t){const r=e.createObjectStore(t.name,t.options);t.indexes?.forEach((e=>{r.createIndex(e.name,e.keyPath,e.options)}))}async addStore(e){if(this.#n.some((t=>t.name===e.name)))throw new Error(`Store ${e.name} already exists`);this.#n.push(e),this.#t++,await this.#c()}async deleteStore(e){this.#n=this.#n.filter((t=>t.name!==e)),this.#t++,await this.#c()}async#c(){this.destroy(),await this.initialize()}async#l(e,t,r){if(!this.#r)throw new Error("Database not initialized");return new Promise(((n,s)=>{const i=this.#r.transaction(e,t),o=i.objectStore(e),a=r(o);a.onsuccess=()=>n(a.result),a.onerror=()=>s(a.error),i.oncomplete=()=>{},i.onerror=()=>s(i.error)}))}async#h(e,t,r,n){if(!this.#r)throw new Error("Database not initialized");return new Promise(((s,i)=>{let o=0,a=!1;const c=this.#r.transaction(e,t),l=c.objectStore(e);n&&n.forEach((e=>{if(a)return;let t;try{t=r(l,e)}catch(e){return a=!0,c.abort(),void i(e)}t.onsuccess=()=>{o++},t.onerror=e=>{a=!0,c.abort(),i(e.target.error)}})),c.oncomplete=()=>{a||s(o)},c.onerror=()=>i(c.error)}))}async add(e,t){return this.#l(e,"readwrite",(e=>e.add(t)))}async addAll(e,t,r=this.#i){let n=0;for(let s=0;s<t.length;s+=r){const i=t.slice(s,s+r);n+=await this.#h(e,"readwrite",((e,t)=>e.add(t)),i)}return n}async get(e,t){return this.#l(e,"readonly",(e=>e.get(t)))}async getAll(e,t,r){return this.#l(e,"readonly",(e=>e.getAll(t,r)))}async getAllByIndexName(e,t,r,n){return this.#l(e,"readonly",(e=>e.index(t).getAll(r,n)))}async getCount(e){return this.#l(e,"readonly",(e=>e.count()))}async put(e,t){return this.#l(e,"readwrite",(e=>e.put(t)))}async putAll(e,t,r=this.#i){let n=0;for(let s=0;s<t.length;s+=r){const i=t.slice(s,s+r);n+=await this.#h(e,"readwrite",((e,t)=>e.put(t)),i)}return n}async delete(e,t){return this.#l(e,"readwrite",(e=>e.delete(t)))}async deleteAll(e,t=[],r=this.#i){let n=0;for(let s=0;s<t.length;s+=r){const i=t.slice(s,s+r);n+=await this.#h(e,"readwrite",((e,t)=>e.delete(t)),i)}return n}async clear(e){return this.#l(e,"readwrite",(e=>e.clear()))}}self.SingletonDBInstance=t}();