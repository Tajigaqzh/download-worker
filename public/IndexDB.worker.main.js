"use strict";!function(){let e=1e3;class t{static#e=null;#t=1;#r=null;#n=[];#s="";constructor(r,n=1e3){if(!r||0===r.trim().length)throw new Error("db name error");if(e&&n>e&&(e=n),t.#e)return t.#e;this.#s=r,t.#e=this}isExistDB=()=>null!==this.#r;isExistTable=e=>!!this.#r&&this.#r.objectStoreNames.contains(e);async initialize(){if(!self.indexedDB)throw new Error("current environment not supported IndexDB");if(this.#r)return Promise.resolve(!0);let t=!1,r=0;const n=()=>new Promise(((e,t)=>{const r=self.indexedDB.open(this.#s,this.#t);r.onupgradeneeded=e=>{const t=e.target.result;this.#o(t,e.oldVersion)},r.onsuccess=t=>{this.#r=t.target.result,e(!0)},r.onerror=t=>{e(!1)}}));for(;r<e&&!t;){if(r++,await n())return t=!0,Promise.resolve(!0);this.#t++}return Promise.reject("创建失败")}destroy(){this.#r&&(this.#r.close(),this.#r=null)}#o(e,t){Array.from(e.objectStoreNames).forEach((t=>{this.#n.some((e=>e.name===t))||e.deleteObjectStore(t)})),this.#n.forEach((t=>{e.objectStoreNames.contains(t.name)||this.#i(e,t)}))}#i(e,t){const r=e.createObjectStore(t.name,t.options);t.indexes?.forEach((e=>{r.createIndex(e.name,e.keyPath,e.options)}))}async addStore(e){if(this.#n.some((t=>t.name===e.name)))throw new Error(`Store ${e.name} already exists`);this.#n.push(e),this.#t++,await this.#a()}async deleteStore(e){this.#n=this.#n.filter((t=>t.name!==e)),this.#t++,await this.#a()}async#a(){this.destroy(),await this.initialize()}async#c(e,t,r){if(!this.#r)throw new Error("Database not initialized");return new Promise(((n,s)=>{const o=this.#r.transaction(e,t),i=o.objectStore(e),a=r(i);a.onsuccess=()=>n(a.result),a.onerror=()=>s(a.error),o.oncomplete=()=>{},o.onerror=()=>s(o.error)}))}async#l(e,t,r,n){if(!this.#r)throw new Error("Database not initialized");return new Promise(((s,o)=>{let i=0,a=!1;const c=this.#r.transaction(e,t),l=c.objectStore(e);n&&n.forEach((e=>{if(a)return;let t;try{t=r(l,e)}catch(e){return a=!0,c.abort(),void o(e)}t.onsuccess=()=>{i++},t.onerror=e=>{a=!0,c.abort(),o(e.target.error)}})),c.oncomplete=()=>{a||s(i)},c.onerror=()=>o(c.error)}))}async add(e,t){return this.#c(e,"readwrite",(e=>e.add(t)))}async addAll(e,t,r=100){let n=0;for(let s=0;s<t.length;s+=r){const o=t.slice(s,s+r);n+=await this.#l(e,"readwrite",((e,t)=>e.add(t)),o)}return n}async get(e,t){return this.#c(e,"readonly",(e=>e.get(t)))}async getAll(e,t){return this.#c("mandarinTestDB","readonly",(r=>r.getAll(e,t)))}async getAllByIndexName(e,t,r,n){return this.#c(e,"readonly",(e=>e.index(t).getAll(r,n)))}async getCount(e){return this.#c(e,"readonly",(e=>e.count()))}async put(e,t){return this.#c(e,"readwrite",(e=>e.put(t)))}async putAll(e,t,r=100){let n=0;for(let s=0;s<t.length;s+=r){const o=t.slice(s,s+r);n+=await this.#l(e,"readwrite",((e,t)=>e.put(t)),o)}return n}async delete(e,t){return this.#c(e,"readwrite",(e=>e.delete(t)))}async deleteAll(e,t=[],r=100){let n=0;for(let s=0;s<t.length;s+=r){const o=t.slice(s,s+r);n+=await this.#l(e,"readwrite",((e,t)=>e.delete(t)),o)}return n}async clear(e){return this.#c(e,"readwrite",(e=>e.clear()))}}self.SingletonDBInstance=t}();